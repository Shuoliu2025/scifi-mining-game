<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸš€ æ˜Ÿé™…æŒ–çŸ¿æŒ‡æŒ¥å®˜</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* ç§‘å¹»èƒŒæ™¯æ˜Ÿç©ºåŠ¨ç”» */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(2px 2px at 20px 30px, #eee, transparent),
                radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
                radial-gradient(1px 1px at 90px 40px, #fff, transparent),
                radial-gradient(1px 2px at 110px 80px, rgba(255,255,255,0.6), transparent);
            background-repeat: repeat;
            background-size: 200px 100px;
            animation: sparkle 3s linear infinite;
            z-index: -1;
        }

        @keyframes sparkle {
            from { transform: translateY(0); }
            to { transform: translateY(-100px); }
        }

        .game-container {
            position: relative;
            width: 800px;
            height: 600px;
            border: 3px solid #00ffff;
            border-radius: 15px;
            overflow: hidden;
            background: linear-gradient(to bottom,
                #0a0a1f 0%,
                #1a1a3e 30%,
                #2d2d5f 30%,
                #3a3a7a 100%);
            box-shadow:
                0 0 20px #00ffff,
                inset 0 0 20px rgba(0, 255, 255, 0.1);
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
        }

        .ui-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 50, 100, 0.6));
            color: #00ffff;
            padding: 15px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            font-family: 'Courier New', monospace;
        }

        .ui-panel div {
            margin: 5px 0;
            text-shadow: 0 0 5px #00ffff;
        }

        .audio-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 50, 100, 0.6));
            color: #00ffff;
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            font-family: 'Courier New', monospace;
        }

        .audio-button {
            background: linear-gradient(135deg, #00ffff, #0080ff);
            color: #000033;
            border: none;
            padding: 5px 10px;
            font-size: 12px;
            border-radius: 5px;
            cursor: pointer;
            margin: 2px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        .audio-button:hover {
            background: linear-gradient(135deg, #00cccc, #0066cc);
        }

        .audio-button.muted {
            background: linear-gradient(135deg, #666666, #333333);
            color: #999999;
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            text-align: center;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 50, 100, 0.6));
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px #00ffff;
        }

        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 50, 100, 0.8));
            color: #00ffff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 15px;
        }

        .start-button {
            background: linear-gradient(135deg, #00ffff, #0080ff);
            color: #000033;
            border: 2px solid #00ffff;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .start-button:hover {
            background: linear-gradient(135deg, #00cccc, #0066cc);
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
        }

        .game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 50, 100, 0.8));
            color: #00ffff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            border: 3px solid #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            font-family: 'Courier New', monospace;
        }

        .game-title {
            font-size: 42px;
            color: #00ffff;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #00ffff;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px #00ffff; }
            to { text-shadow: 0 0 30px #00ffff, 0 0 40px #0080ff; }
        }

        .subtitle {
            font-size: 18px;
            color: #80d4ff;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #80d4ff;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div class="ui-panel">
            <div>ğŸ”‹ èƒ½é‡: <span id="score">0</span></div>
            <div>ğŸ¯ ç›®æ ‡: <span id="target">1000</span></div>
            <div>â±ï¸ æ—¶é—´: <span id="time">60</span>s</div>
            <div>ğŸŒŸ ç­‰çº§: <span id="level">1</span></div>
        </div>

        <div class="audio-controls">
            <div style="margin-bottom: 5px; font-size: 14px; text-align: center;">ğŸ”Š éŸ³æ•ˆæ§åˆ¶</div>
            <button class="audio-button" id="musicToggle" onclick="toggleMusic()">ğŸµ éŸ³ä¹</button>
            <button class="audio-button" id="sfxToggle" onclick="toggleSFX()">ğŸ”Š éŸ³æ•ˆ</button>
        </div>

        <div class="controls">
            ç‚¹å‡»å±å¹•å‘å°„é‡‡çŸ¿æ¿€å…‰æŸï¼<br>
            ğŸ¯ ç»¿è‰²æŒ‡ç¤ºå™¨äº®èµ·æ—¶ç‚¹å‡»å‘å°„ | ğŸ“ é»„è‰²ç®­å¤´æ˜¾ç¤ºæ¿€å…‰æ‘†åŠ¨æ–¹å‘<br>
            âš¡ è™šçº¿æ˜¾ç¤ºæ¿€å…‰æ‘†åŠ¨èŒƒå›´ | ğŸ¯ ç„å‡†æ—¶æœºå¾ˆé‡è¦ï¼
        </div>

        <div class="start-screen" id="startScreen">
            <h1 class="game-title">ğŸš€ æ˜Ÿé™…æŒ–çŸ¿æŒ‡æŒ¥å®˜ âš¡</h1>
            <p class="subtitle">
                ä½¿ç”¨å…ˆè¿›çš„é‡‡çŸ¿æ¿€å…‰æŒ–æ˜å¤–æ˜Ÿå®è—ï¼<br>
                èƒ½é‡æ™¶ä½“ä»·å€¼æœ€é«˜ï¼Œç¨€æœ‰çŸ¿ç‰©æ›´çè´µ<br>
                å°å¿ƒçˆ†ç‚¸è£…ç½®å’ŒåºŸæ–™ï¼
            </p>
            <button class="start-button" onclick="startGame()">å¯åŠ¨ä»»åŠ¡</button>
        </div>

        <div class="game-over" id="gameOver">
            <h2 style="color: #00ffff; margin-bottom: 20px; text-shadow: 0 0 15px #00ffff;">ä»»åŠ¡å®Œæˆï¼</h2>
            <p>æœ€ç»ˆèƒ½é‡: <span id="finalScore">0</span></p>
            <p>è¾¾åˆ°ç­‰çº§: <span id="finalLevel">1</span></p>
            <button class="start-button" onclick="restartGame()" style="margin-top: 15px;">é‡æ–°ä»»åŠ¡</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // æ¸¸æˆçŠ¶æ€
        let gameState = 'start'; // start, playing, paused, gameOver
        let score = 0;
        let level = 1;
        let timeLeft = 60;
        let target = 1000;

        // éŸ³é¢‘è®¾ç½®
        let audioEnabled = {
            music: true,
            sfx: true
        };

        // éŸ³é¢‘å¯¹è±¡
        let audioContext;
        let sounds = {};

        // åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿ
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // åˆ›å»ºç§‘å¹»éŸ³æ•ˆ
                sounds = {
                    shoot: createBeepSound(800, 0.1, 'square'),
                    collect: createBeepSound(1200, 0.2, 'triangle'),
                    explosion: createNoiseSound(0.3),
                    levelUp: createMelodySound([800, 1000, 1200], 0.5),
                    background: createBackgroundMusic()
                };
            } catch (e) {
                console.warn('éŸ³é¢‘åˆå§‹åŒ–å¤±è´¥:', e);
                audioEnabled.music = false;
                audioEnabled.sfx = false;
            }
        }

        // åˆ›å»ºèœ‚é¸£éŸ³æ•ˆ
        function createBeepSound(frequency, duration, waveType = 'sine') {
            return () => {
                if (!audioEnabled.sfx || !audioContext) return;

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = waveType;

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            };
        }

        // åˆ›å»ºå™ªéŸ³æ•ˆæœï¼ˆçˆ†ç‚¸éŸ³ï¼‰
        function createNoiseSound(duration) {
            return () => {
                if (!audioEnabled.sfx || !audioContext) return;

                const bufferSize = audioContext.sampleRate * duration;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }

                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();

                source.buffer = buffer;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);

                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

                source.start(audioContext.currentTime);
            };
        }

        // åˆ›å»ºæ—‹å¾‹éŸ³æ•ˆ
        function createMelodySound(frequencies, totalDuration) {
            return () => {
                if (!audioEnabled.sfx || !audioContext) return;

                const noteDuration = totalDuration / frequencies.length;

                frequencies.forEach((freq, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    oscillator.type = 'triangle';

                    const startTime = audioContext.currentTime + index * noteDuration;
                    gainNode.gain.setValueAtTime(0.2, startTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + noteDuration);

                    oscillator.start(startTime);
                    oscillator.stop(startTime + noteDuration);
                });
            };
        }

        // åˆ›å»ºèƒŒæ™¯éŸ³ä¹
        function createBackgroundMusic() {
            let backgroundOscillator = null;
            let backgroundGain = null;
            let isPlaying = false;

            return {
                start: () => {
                    if (!audioEnabled.music || !audioContext || isPlaying) return;

                    backgroundOscillator = audioContext.createOscillator();
                    backgroundGain = audioContext.createGain();

                    backgroundOscillator.connect(backgroundGain);
                    backgroundGain.connect(audioContext.destination);

                    backgroundOscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                    backgroundOscillator.type = 'sawtooth';

                    backgroundGain.gain.setValueAtTime(0.05, audioContext.currentTime);

                    // åˆ›å»ºä½é¢‘æŒ¯è¡æ•ˆæœ
                    const lfo = audioContext.createOscillator();
                    const lfoGain = audioContext.createGain();

                    lfo.connect(lfoGain);
                    lfoGain.connect(backgroundOscillator.frequency);

                    lfo.frequency.setValueAtTime(0.5, audioContext.currentTime);
                    lfoGain.gain.setValueAtTime(10, audioContext.currentTime);

                    backgroundOscillator.start();
                    lfo.start();

                    isPlaying = true;
                },
                stop: () => {
                    if (backgroundOscillator && isPlaying) {
                        backgroundOscillator.stop();
                        backgroundOscillator = null;
                        backgroundGain = null;
                        isPlaying = false;
                    }
                }
            };
        }

        // æ’­æ”¾éŸ³æ•ˆ
        function playSound(soundName) {
            if (sounds[soundName] && typeof sounds[soundName] === 'function') {
                sounds[soundName]();
            } else if (sounds[soundName] && sounds[soundName].start) {
                sounds[soundName].start();
            }
        }

        // åœæ­¢éŸ³æ•ˆ
        function stopSound(soundName) {
            if (sounds[soundName] && sounds[soundName].stop) {
                sounds[soundName].stop();
            }
        }

        // åˆ‡æ¢éŸ³ä¹
        function toggleMusic() {
            audioEnabled.music = !audioEnabled.music;
            const button = document.getElementById('musicToggle');

            if (audioEnabled.music) {
                button.classList.remove('muted');
                button.textContent = 'ğŸµ éŸ³ä¹';
                if (gameState === 'playing') {
                    playSound('background');
                }
            } else {
                button.classList.add('muted');
                button.textContent = 'ğŸ”‡ éŸ³ä¹';
                stopSound('background');
            }
        }

        // åˆ‡æ¢éŸ³æ•ˆ
        function toggleSFX() {
            audioEnabled.sfx = !audioEnabled.sfx;
            const button = document.getElementById('sfxToggle');

            if (audioEnabled.sfx) {
                button.classList.remove('muted');
                button.textContent = 'ğŸ”Š éŸ³æ•ˆ';
            } else {
                button.classList.add('muted');
                button.textContent = 'ğŸ”‡ éŸ³æ•ˆ';
            }
        }

        // ç§‘å¹»çŸ¿å·¥æœºå™¨äºº
        let miner = {
            x: 400,
            y: 100,
            width: 60,
            height: 80
        };

        let hook = {
            x: 400,
            y: 180,
            length: 50,
            angle: 0,
            speed: 0.027, // å‡å°‘10%ï¼š0.03 * 0.9 = 0.027
            state: 'swinging', // swinging, extending, retracting, pulling
            maxLength: 450,
            extendSpeed: 5,
            retractSpeed: 3,
            caughtItem: null
        };

        // å®ç‰©æ•°ç»„
        let treasures = [];

        // ç§‘å¹»å®ç‰©ç±»å‹å®šä¹‰
        const treasureTypes = {
            energy_small: { value: 50, weight: 1, color: '#00ff00', size: 20, symbol: 'â—†' },
            energy_medium: { value: 100, weight: 2, color: '#00ff88', size: 30, symbol: 'â—†' },
            energy_large: { value: 200, weight: 4, color: '#00ffff', size: 40, symbol: 'â—†' },
            crystal: { value: 500, weight: 3, color: '#ff00ff', size: 25, symbol: 'ğŸ’' },
            debris: { value: 10, weight: 5, color: '#666666', size: 35, symbol: 'â– ' },
            explosive: { value: -100, weight: 1, color: '#ff0000', size: 25, symbol: 'ğŸ’¥' }
        };

        // åˆå§‹åŒ–å®ç‰©
        function initTreasures() {
            treasures = [];
            const types = Object.keys(treasureTypes);

            for (let i = 0; i < 15; i++) {
                const type = types[Math.floor(Math.random() * types.length)];
                const treasure = {
                    type: type,
                    x: Math.random() * 700 + 50,
                    y: Math.random() * 350 + 250,
                    ...treasureTypes[type],
                    collected: false
                };
                treasures.push(treasure);
            }
        }

        // ç»˜åˆ¶ç§‘å¹»çŸ¿å·¥æœºå™¨äºº
        function drawMiner() {
            // æœºå™¨äººä¸»ä½“
            ctx.fillStyle = '#333366';
            ctx.fillRect(miner.x - miner.width/2, miner.y - miner.height, miner.width, miner.height);

            // æœºå™¨äººè¾¹æ¡†å‘å…‰æ•ˆæœ
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(miner.x - miner.width/2, miner.y - miner.height, miner.width, miner.height);

            // æœºå™¨äººå¤´éƒ¨
            ctx.fillStyle = '#404080';
            ctx.fillRect(miner.x - 25, miner.y - miner.height - 15, 50, 20);

            // å¤´éƒ¨å‘å…‰è¾¹æ¡†
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(miner.x - 25, miner.y - miner.height - 15, 50, 20);

            // çœ¼ç›LEDç¯
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(miner.x - 10, miner.y - miner.height - 5, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(miner.x + 10, miner.y - miner.height - 5, 3, 0, Math.PI * 2);
            ctx.fill();

            // å¤©çº¿
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(miner.x, miner.y - miner.height - 15);
            ctx.lineTo(miner.x, miner.y - miner.height - 25);
            ctx.stroke();

            // å¤©çº¿é¡¶ç«¯é—ªçƒç¯
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(miner.x, miner.y - miner.height - 25, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // ç»˜åˆ¶ç§‘å¹»æ¿€å…‰æŸ
        function drawHook() {
            const hookX = miner.x + Math.sin(hook.angle) * hook.length;
            const hookY = miner.y + Math.cos(hook.angle) * hook.length;

            // ç»˜åˆ¶æ¿€å…‰æ‘†åŠ¨èŒƒå›´æŒ‡ç¤ºå™¨ï¼ˆåªåœ¨æ‘†åŠ¨çŠ¶æ€æ—¶æ˜¾ç¤ºï¼‰
            if (hook.state === 'swinging') {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 8]);

                // å·¦è¾¹ç•Œ
                const leftX = miner.x + Math.sin(-Math.PI/3) * 80;
                const leftY = miner.y + Math.cos(-Math.PI/3) * 80;
                ctx.beginPath();
                ctx.moveTo(miner.x, miner.y);
                ctx.lineTo(leftX, leftY);
                ctx.stroke();

                // å³è¾¹ç•Œ
                const rightX = miner.x + Math.sin(Math.PI/3) * 80;
                const rightY = miner.y + Math.cos(Math.PI/3) * 80;
                ctx.beginPath();
                ctx.moveTo(miner.x, miner.y);
                ctx.lineTo(rightX, rightY);
                ctx.stroke();

                ctx.setLineDash([]);
            }

            // æ¿€å…‰æŸä¸»ä½“ï¼ˆå‘å…‰æ•ˆæœï¼‰
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(miner.x, miner.y);
            ctx.lineTo(hookX, hookY);
            ctx.stroke();

            // æ¿€å…‰æŸå†…æ ¸
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(miner.x, miner.y);
            ctx.lineTo(hookX, hookY);
            ctx.stroke();

            // æ¿€å…‰æŸæœ«ç«¯é‡‡çŸ¿è£…ç½®
            ctx.shadowColor = '#ff0080';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#00ccff';
            ctx.beginPath();
            ctx.arc(hookX, hookY, 15, 0, Math.PI * 2);
            ctx.fill();

            // é‡‡çŸ¿è£…ç½®è¾¹æ¡†
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(hookX, hookY, 15, 0, Math.PI * 2);
            ctx.stroke();

            // é‡‡çŸ¿è£…ç½®å†…éƒ¨
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(hookX, hookY, 6, 0, Math.PI * 2);
            ctx.fill();

            // çŠ¶æ€æŒ‡ç¤ºå™¨
            if (hook.state === 'swinging') {
                ctx.shadowColor = '#00ff00';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(hookX, hookY - 30, 8, 0, Math.PI * 2);
                ctx.fill();

                // æ‘†åŠ¨æ–¹å‘å…¨æ¯ç®­å¤´
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffff00';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                const direction = hook.speed > 0 ? 'â†’' : 'â†';
                ctx.fillText(direction, hookX, hookY - 40);
            }

            // é‡ç½®é˜´å½±
            ctx.shadowBlur = 0;

            // æ›´æ–°é’©çˆªä½ç½®
            hook.x = hookX;
            hook.y = hookY;
        }

        // ç»˜åˆ¶ç§‘å¹»å®ç‰©
        function drawTreasures() {
            treasures.forEach(treasure => {
                if (!treasure.collected) {
                    // ä¸ºå®ç‰©æ·»åŠ å‘å…‰æ•ˆæœ
                    ctx.shadowColor = treasure.color;
                    ctx.shadowBlur = 8;
                    ctx.fillStyle = treasure.color;
                    ctx.font = `${treasure.size}px Arial`;
                    ctx.textAlign = 'center';

                    if (treasure.symbol === 'ğŸ’¥') {
                        ctx.fillText(treasure.symbol, treasure.x, treasure.y);
                    } else if (treasure.symbol === 'ğŸ’') {
                        ctx.fillText(treasure.symbol, treasure.x, treasure.y);
                    } else if (treasure.symbol === 'â—†') {
                        // èƒ½é‡æ™¶ä½“ç‰¹æ®Šç»˜åˆ¶
                        ctx.beginPath();
                        ctx.moveTo(treasure.x, treasure.y - treasure.size/2);
                        ctx.lineTo(treasure.x + treasure.size/3, treasure.y);
                        ctx.lineTo(treasure.x, treasure.y + treasure.size/2);
                        ctx.lineTo(treasure.x - treasure.size/3, treasure.y);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // åºŸæ–™æ–¹å—
                        ctx.fillRect(treasure.x - treasure.size/2, treasure.y - treasure.size/2,
                                   treasure.size, treasure.size);
                    }

                    ctx.shadowBlur = 0;
                }
            });
        }

        // ç¢°æ’æ£€æµ‹
        function checkCollision(x1, y1, size1, x2, y2, size2) {
            const distance = Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
            return distance < (size1 + size2) / 2;
        }

        // æ›´æ–°é’©çˆªçŠ¶æ€
        function updateHook() {
            if (hook.state === 'swinging') {
                hook.angle += hook.speed;
                if (hook.angle > Math.PI/3 || hook.angle < -Math.PI/3) {
                    hook.speed = -hook.speed;
                }
            } else if (hook.state === 'extending') {
                hook.length += hook.extendSpeed;

                // æ£€æŸ¥æ˜¯å¦ç¢°åˆ°å®ç‰©
                treasures.forEach(treasure => {
                    if (!treasure.collected && checkCollision(hook.x, hook.y, 20, treasure.x, treasure.y, treasure.size)) {
                        hook.caughtItem = treasure;
                        treasure.collected = true;
                        hook.state = 'retracting';

                        // æ’­æ”¾æ”¶é›†éŸ³æ•ˆ
                        if (treasure.type === 'explosive') {
                            playSound('explosion');
                            score += treasure.value;
                            updateScore();
                        } else {
                            playSound('collect');
                        }
                    }
                });

                // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾æœ€å¤§é•¿åº¦æˆ–åº•éƒ¨
                if (hook.length >= hook.maxLength || hook.y >= canvas.height - 20) {
                    hook.state = 'retracting';
                }
            } else if (hook.state === 'retracting') {
                const retractSpeed = hook.caughtItem ?
                    Math.max(1, hook.retractSpeed - hook.caughtItem.weight * 0.5) :
                    hook.retractSpeed;

                hook.length -= retractSpeed;

                // æ‹–æ‹½ç‰©å“
                if (hook.caughtItem) {
                    hook.caughtItem.x = hook.x;
                    hook.caughtItem.y = hook.y;
                }

                // æ£€æŸ¥æ˜¯å¦è¿”å›åˆ°çŸ¿å·¥ä½ç½®
                if (hook.length <= 50) {
                    if (hook.caughtItem) {
                        score += hook.caughtItem.value;
                        updateScore();
                        hook.caughtItem = null;
                    }

                    hook.length = 50;
                    hook.state = 'swinging';
                    hook.angle = 0;
                    hook.speed = 0.027; // ä¿æŒå‡å°‘åçš„é€Ÿåº¦
                }
            }
        }

        // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
        function updateScore() {
            document.getElementById('score').textContent = score;

            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ç›®æ ‡
            if (score >= target) {
                levelUp();
            }
        }

        // å‡çº§
        function levelUp() {
            level++;
            target += 1000;
            timeLeft += 30;
            document.getElementById('level').textContent = level;
            document.getElementById('target').textContent = target;

            // æ’­æ”¾å‡çº§éŸ³æ•ˆ
            playSound('levelUp');

            // é‡æ–°ç”Ÿæˆå®ç‰©
            initTreasures();
        }

        // æ¸¸æˆå¾ªç¯
        function gameLoop() {
            if (gameState !== 'playing') return;

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶å¤–æ˜Ÿåœ°è¡¨èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 200, 0, canvas.height);
            gradient.addColorStop(0, '#4a4a8a');
            gradient.addColorStop(1, '#2a2a5a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 200, canvas.width, canvas.height - 200);

            // ç»˜åˆ¶åœ°è¡¨çº¹ç†çº¿æ¡
            ctx.strokeStyle = '#6a6aaa';
            ctx.lineWidth = 1;
            for (let i = 220; i < canvas.height; i += 40) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            // ç»˜åˆ¶æ¸¸æˆå…ƒç´ 
            drawTreasures();
            drawMiner();
            drawHook();

            // æ›´æ–°é’©çˆª
            updateHook();

            requestAnimationFrame(gameLoop);
        }

        // è®¡æ—¶å™¨
        function startTimer() {
            const timer = setInterval(() => {
                if (gameState === 'playing') {
                    timeLeft--;
                    document.getElementById('time').textContent = timeLeft;

                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        endGame();
                    }
                } else {
                    clearInterval(timer);
                }
            }, 1000);
        }

        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            gameState = 'playing';
            document.getElementById('startScreen').style.display = 'none';

            // åˆå§‹åŒ–éŸ³é¢‘
            if (!audioContext) {
                initAudio();
            }

            // å¯åŠ¨èƒŒæ™¯éŸ³ä¹
            if (audioEnabled.music) {
                playSound('background');
            }

            initTreasures();
            gameLoop();
            startTimer();
        }

        // ç»“æŸæ¸¸æˆ
        function endGame() {
            gameState = 'gameOver';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('gameOver').style.display = 'block';

            // åœæ­¢èƒŒæ™¯éŸ³ä¹
            stopSound('background');
        }

        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            gameState = 'start';
            score = 0;
            level = 1;
            timeLeft = 60;
            target = 1000;

            // åœæ­¢èƒŒæ™¯éŸ³ä¹
            stopSound('background');

            // é‡ç½®UI
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('time').textContent = timeLeft;
            document.getElementById('target').textContent = target;
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';

            // é‡ç½®é’©çˆª
            hook.length = 50;
            hook.angle = 0;
            hook.state = 'swinging';
            hook.speed = 0.027; // ä¿æŒå‡å°‘åçš„é€Ÿåº¦
            hook.caughtItem = null;
        }

        // é¼ æ ‡ç‚¹å‡»äº‹ä»¶
        canvas.addEventListener('click', (e) => {
            if (gameState === 'playing' && hook.state === 'swinging') {
                hook.state = 'extending';
                // æ’­æ”¾å‘å°„éŸ³æ•ˆ
                playSound('shoot');
            }
        });

        // åˆå§‹åŒ–æ¸¸æˆ
        initTreasures();
    </script>
</body>
</html>